Приобразование данных
X="25";
y=+x;
y=Namber(x);
parseInt(x);
parsefloat(x)?


logical
z=Boolean(x);
z=!!x;1

String

z=String(y);
z=y+"";

Цикл многократное выполнение группы операторов до достижения опред условия
Do {
While(условие)
}
While (условие ) {
}

for(){
}

for(in){}

FOR(of){}iter tor

Массивы
 Это объектный тип данных. Используется для хранения множества значений. Разного типа .

Размерность это ( длина массива )колличество элементов хранящихся в массиве

crud CREAT
2 формы создания массива
1 литеральная
var arr=[]; [1,8,true]
2 объектная
var arr=newArray();
var arr=newArray(20);      создаст массив из 20 элементов с индефами внутри .

Последовательность операторов кот выполняют вычисления над массивом
Arr.имя_свойства;
Arr.length; // namber int челочисленное (длина массива )
Arr.length=200 достроит массив до 200эллементов
Arr.length=0 уничтожает все данные в массиве .
Методы в массивах
Arr[arr.length]=5 приклеивает в конец массива значение
Arr.push(x) x любой тип  закидывает в конец значение .
.pop () удалить последний элемент ели x= то сохран знач в х
Arr.length= arr.length-1 -//-х

Срез массива
Arr.unshift(x) добавить элем в нач
Arr.shift() удалить элем с начала . Х= тоже сохранит элемент в

.slice(start I , end I) end не включая конец можно не указывать
Результат это новый массив
Удаление элементов из массива
.splice (I , k, r ) индекс колличество. . R можно заменить на это


Преобразование массива в строку
.join(sep)

.concat(arr) создаёт новый массив из двух старых
Копия. newarr=[].concat(arr)

.reverse () переворачивает массив

.sort(callback) можем передать функцию

Array.isArray(x) проверка на массив .

arr.:ncludes(x)



Дз массивы

Запросить число // 4
В один лог вывести
Триугольник сформированный из числа
*

*
****

И
****
*

*

И

****
 *



Шпаргалка по методам массива:

Для добавления/удаления элементов:

push (...items) – добавляет элементы в конец,
pop() – извлекает элемент с конца,
shift() – извлекает элемент с начала,
unshift(...items) – добавляет элементы в начало.
splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
findIndex похож на find, но возвращает индекс вместо значения.
Для перебора элементов:

forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
Для преобразования массива:

map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
sort(func) – сортирует массив «на месте», а потом возвращает его.
reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
split/join – преобразует строку в массив и обратно.
reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
Дополнительно:

Array.isArray(arr) проверяет, является ли arr массивом.
Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.

arr.some(fn)/arr.every(fn) проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).   *

   многомерный рандомный массив
   перестановка первой и поледней столбика
   сумма элементов в строке
   и столбце
   максимальный элемент заменить звездочкой

   var n = randomInteger(3,5);
   var array = [];
   var str=""; var strNew="";

   for(let i=0;i<n; i++){
   	array.push([]);
   	// array = [[]]
   	//i=0

   	// i=1
   	// [[2,6,3], [3,4,5], []]
   	for(let j=0;j<n; j++){
   		// j=0 [[2]]
   		// j=1 [[2,6]]
   		// j=2 [[2,6,3]]
   		array[i].push(randomInteger(1,9))
   	}

   	str+=array[i].join(" ") + "\n";

   	//i=2
   }

   let temp = array[0];
   	array[0]=array[array.length-1];
   	array[array.length-1] = temp;

   for(let i=0;i<n; i++){
   	strNew+=array[i].join(" ") + "\n";
   }



   \\\ строки \\\\

   создание строк
   обьектная форма записли  let str=newString("x")
   литеральная форма записи let str="x" \\ str='x' \\ str=`x` (можно выполнять любые операторы внутри стороки)
   строка это псевдо-массив
   str.charAt(i) == x[2]
   у строки есть длинна (колво символов) x.length
   !!!строки в js не изменны
   все мктоды относительно строк возвращают новую строку
   x.trim() урезание пробелов в начале и в конце строки
   x.toUpperCase() все в верхнии регистр
   x.toLowerCase() все в нижний регистр
   x.link(url)

   y.includes(str) возвращает тру или фолс (поиск по строке )
   y.startsWhis(str) проверка на наало и конец строки на наличике str
    y.endsWhis(str)

y.indexOf(str) или (ste, start) можно указать начало откуда искать
возвращает индекс с какой позиции началось str если нет то будет фолс(-1)
y.lastIndex(x,index) работает с право налево
str.localCompare(str2)

преобразование str в реальный массив
arr=x=split(" ", limit) если в "" пусто дробит массив посимвольно если " " то по свловам до пробела и тд
если в "" чтото он убирает это из текста

дз
в веденой пользователем строке, найти самую большую последовательность символов в слове и вывести
и отсортировать все слова по возрастанию
подщитать кол-во гласнных и согласных

2 массива от 1-10 длинной 10
1 рандомный 2й по возрастанию найти пропущенный символ

многомерный массив приобразовать в одномерный


 каникулы с 27-17


функции
аргументы входные данные кот используются для динамики функции
не для всех функций нужны аргументы
function имя(аргументы){
    тело функции
}
  видимость функции
  локальная
  создается только внутири функции
  уничтожаются по завершению работы функции
  используют минимум ОП
  улутшают производительность кода

    глобальная
    создается в основном потоке
    доступна везде
    использут много ресурсов ОП


    что функция выполняет
    какие параметры я могу передовать ?(типы данных)
    какой рез-т возвращается (тип данных )

    иэтот способ называется functiondecloration

    functionexpression
    sum=function(){}

    используем когда тело функции динамическое
    либо нужно функцию вызвать 1 раз

    arrow function
    стрелочные функции
    имеют особенность нет своего this


лексическое окружение и скоуп называет замыканием
механизм работы облати видимости

скоуп изменить нельзя

п
события
есть несколько групп событий
1 события мыши
2 клавиатура
3 события форм
4 события загрузки логов
5 события анимаций

есть два способа создания событий
событие можно прикреплять  к элементу(там) в самом штмл
достигается это при помощи атрибутов

первый
клик
<p onklick="js">asdad</p>
тип события "обработчик" это функция

второй топ
test.oncontextmenu=elemClick

метод .addEventListener(type,fn)

обращение к элементу (ко всем  элементам ) это будет [] псевдо массив
document.getElementsByTagName("p")


document.getElementsByClassName("p")
document.getElementById("p")

оброботчик функции this он обращается к элементу кот отправил событие
this работает по разному в зависимости от кода

innerHtml выводит содержимое тега включая html
innerText вывводит только содержимое

.children ижет дочерные элементы в текущем узле
..document.querySelectorAll("по цсс")   возвращает псевдомассив с итогами поиска
..document.querySelector("по цсс") возвращает первый элемент

.nextElementSibling свойство только для чтения,
 возвращающее последующий элемент перед текущим, или null,
 если элемент является последним в своём родительском узле.

.previousElementSibling только для чтения возвращает
 Element элемент стоящий перед применяемым, из списка дочерних
 элементов родителя или возвращает null, если таковых не имеется.

создание элементов html с помощью js
var x=document.createElement(name) name=string
data-*префикс для хранения данных


методы добавления тега в html

document.body.prepend(x) добавляет после открывающегося тега

document.body.apppend(x)  перед закрывающимся

добавление середину
document.querySelector(".menu > li:first-child")
li.insertAdjacentElement(where(str),what(obj))
where - beforeBegin, afterBegin,beforeEnd,afterEnd.

копия элемента со всем содержимым
let copy=x.cloneNode(type(boolean));
с содержимым true и без него false

удаление обектов
x.remove(); если нужно сохранить то можно в с помощью let y=x.remove();


читая функция которыя принимает хотябы 1 оргумент , не меняет данные из глобальной области видимости ,
возвращает результат , вычисления на базе входных данных.

Event
объект евент создается в обработчике йнкиции
создается автоматически
event.type тип события (клик и тд ) используется при делегировании события
event.clientX .clientY положение курсора мыши на момент события отнолительно левого верхнего угла рабочей области

.screenX .screenY ожесамое относительно окна браузера

 .preventDefault() выключает браузерное действие (если выключили включить обратно нельзя)

 .wheelDelta определяет кручение колеса значение -120 то вниз , 120 вверх , чтобы работало нужно событие "onwheel"

 .which возвращает альт код нашей клавиши

 .keyCode -\\- + возвращает и обрабатывает мышку все клики

 .altKey

 .ctrlKey

 .shiftKey  возвращает тру или фолс если клавиша нажата.

 onkeyup
 onkeydown
 onkeypress  чаще всего вешают эти события на window \

 .mouseMove реагирут на движение мыши

есть отложенные(1раз) выполнения функций и интервальный через определенный интервал

отложенные setTimeout (fn,deley)
у сеттаймаута this на главный объект \

setInterval(fn, interval)

clearInterval(fn) остановить интервал

формы
action="url"
method="x" способ отправки данных
get спользуется для получения данных параметры передаютсмя на прямую в url (по дефолту используется )
post отравляет данные в http заголовки .. используются для создания записи
put тожесамое что и пост только используется для обновления данных
delete удаляет данные

4 группы элементов форм
1 текстовые поля ( пояля ввода для емайл и тп)
2 флаги и переключатели
3 кнопки (submit, file, button(кнопка общего назначения), reset(очистка формы)
4 списки(select)

1 текстовые поля
    <input type="" name=""/>
    name =и на фронте и на бэке имя будет одинаковым , это точка благодаря кот мы можем получить доступ к элементу.
    type = text, текстовое поляя для ввода
            password тожесамое что и тексто но значение скрыто
            email тоже текстовое значение но она обязательно будет такого вида xxx@xxxx.xx
            number 213123

    <textarea></textarea>
            тоже должен быть атрибут name

флаги и переключатели
    type = radio
    checked утанавливает значе по умолчанию
    имя у переключателей должно быть одно и тоже
     value="1"    обязательно должно бы то значение
    <P>
    <input type="radio" name=""/>
    вкл
    </p>

        type = checkbox


списки
    <select name="обязательно" multiple(дает возможность множнственного выбора)>
        <option value="тоже обязательно">минск</option> \\Условно дефолт
        <option selected(чтобы было выбрано по умолчанию)>БРЕСТ</option>
    </select>

кнопки
     <input type="" name="" value="текст что будет на кнопке"/>
         type = submit,file(можно много с пом multiple),button,reset

C file дожен быть enctupe="multipart/form-data" иначе не отправятся значения

получения доступа к форме!!!!
    document.forms коллекция форм на странице
    qweryselector(form[name="reg"])
    но лучше и быстрее
    document.forms[`reg`] или document.forms.reg

    доступ к элементам формы
    document.forms.reg.elements псевдо массив всех элементов формы только input textarea select и все только то что относитсяк формам
    document.forms.reg.elements[`name-form`] быстрый доступ к нужной области формы
    document.forms.reg.elements.name-form

    можно х = document.forms.reg.elements.name-form
    x.value можем забрать значение в виде " " строки
    x.value = 100; запись инфы

    file нельзя изменять значение .

    можно сделать поле неактивным x.disabled(озвращает тру или фолс ) = true
    x.name можно забрать имя и изменить
    x.type можно забрать тип и поменять


    функция высшего порядка это функция кот в аргументе принемает функцию

    submit событие возникает при отправки форм


    onblur

    onfocus

    .files относится только к инпутам у которых есть тип файл


    регулярные выражения (не js) своего рода шаблоны
    1. регулярные выражения это шаблон , кот используется для обработки строк. те мы обрабатываем только стровки .

    есть две формы записи . обьектная и литеральная
    литеральная
    let rxExp=/регвыр/флаг(ключ);
    =/\d{2}/ поиск 2х цыфр идущих подрят


    флаги без пробелов
    g - глобальность ( по всей переменной0
    m - мультистрочность
    i - регистро независимость


    обьектная
    let rexExp= new RegExp(body,flags);

    new RegExp("\\d{2}"(или `\d{2}`),"g");

    обектная форма записи интересна если рег выр динамическое

    классы Рег выр
   \d 0-9
   \w a-z 0-9 _
   \s пробелы
   . любой символ
   \b границы слова
   \D \W \S \B НЕ ИЛИ КРОМЕ

   номер телефона
   ххх-хх-хх
   /\d\d\d-\d\d-\d\d/


   квантификаторы
   1. повторения
   /\d{3}  фигурных скобках указывается повторения

    + предществующая конструкция может встречатся один и более раз
    ? предществующая конструкция может встречатся ноль или 1 раз
    * предществующая конструкция может встречатся ноль и более раз

   повтореня рег выражения
   /\d{3}(-\d{2}){2}/

   наборы
   /\w[a-z]{3}\d[5-9]{2}

   ^символ исключает набор

   /[a-z]{3}[5-9]{2}

    /\d{3}([-]{0,1}\d{2}){2}/

    или (29|44|33|25|)

   /^\d{3}(-\d{2}){2}$/ установка соответсвия

   css ситлезация по атрибутам
   $=".png"
   *
   ^

    методы :
    есть ктот относятся к обьекту str и есть те кто относ к regexp
    str.replace(regexp,"")
    rez = str.match(regexp); щет соответсвие рег выр и возвр значение .
    аналог re.exec(str);
    rez.input строка где был поиск
    rez.index место где найдено

    indexOf возвр индекс первого вхождения
    re.test(str) проверяет соответствует ли рег выр строке , если да тру если нет фолс

    regexp101.com



    дата и время
    создание обьекта времени
    let date=new Date(); в переменной находится врем яна момент запуска скрипта.
    let date=new Date(x);можно указать namber & string ;
    отсчет идет от  1 января 1970 г. UTC
    это старт даты и времени в ОС linux
    х это количество МС от данной даты и времени  если это число
    если строка
    "9/17/2020 14:33:15:135" "9-17-2020"

    let date=new Date(y,m,d,h,m,s);

    методы
    date.getFullYear();
    date.getMonth();
    date.getDate();
    date.getDay();
    date.getHours();
    date.getMinutes();
    date.getSeconds();
    date.getTime(); возвращает кол-во милисекунд с начала времени отсчета с 1970года

    date.setFullYear(x);
    date.setMonth(x);
    date.setDate(x);
    date.setDay(x);
    date.setHours(x);
    date.setMinutes(x);
    date.setSeconds(x);
    date.setTime(x);

    date.toString();
    date.toLocaleString(lang,obj)
    date.now колво мс на тек момент

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date


cookies
~~~~~~~~~~~~~~~~~~~~~
это текстовый файл в кот хранится инфа . файл записывается на стороне клиента , в пределах браузера.
для работы куки надо :
1.http(s) (httpd)
2 domain уки пишутся только на базе домена.

document.cookie == "str"
сохранить куку
document.cookie ="key=ivan" key регистрозависимый
document.cookie ="user_city=Minsk"
пар ключей есть ограничение от 20 до 50 шт и 4кб
document.cookie ="city=Minsk" \\ сессионный кук
document.cookie ="city=Minsk; expires=Date"; \\ можно установить время жизни кука
document.cookie ="city=Minsk; max-age=x" где Х колво сек от момента установки куки
document.cookie ="city=Minsk;domain=*.onliner.by
document.cookie ="city=Minsk;domain=*.onliner.by;path=/test/" только по пути path будет доступна кука.




обьекты !!!
ве формы создания обекта
литеральная
let obj={};
обьектна
let obj=new Object();


delete obj.name удаления куска обьекта

obj.info.tel

проверка ключа !!!
if ("key" in obj){}


если вместо ключа нужна переменная то нужно писать так obj.[x]

for ( let key in obj){
console.log(obj[key])
}

for (value of obj){}
for of работает только тогда когда у обьекта есть итератор...

ассациативный массив ото массив вида ключ значение.
иногда называют словарь или хэш

Когда у нас значение хранимое в обьекте отлично от функции такую пару называют свойство.
this в контексте оьекта это ссылка на так обьект

let y=obj;
создаст ссылку

 чтоб сделать копию

let user = {
  name: "John",
  age: 30
};
let clone = {}; // новый пустой объект
// скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}
// теперь в переменной clone находится абсолютно независимый клон объекта.
clone.name = "Pete"; // изменим в нём данные

копия

 Object.assign.

Синтаксис: Object.assign(dest, [src1, src2, src3...])
Аргументы dest, и src1, ..., srcN (может быть столько, сколько нужно) являются объектами.
Метод копирует свойства всех объектов src1, ..., srcN в объект dest.
То есть, свойства всех перечисленных объектов, начиная со второго,
копируются в первый объект. После копирования метод возвращает объект dest.

функуция кот создает обекты опред вида называют с большой бокувы имя
Fn User(x,y){
this.name=x;
this.age=y;
this.show=fn(){return this.name};
}
let x=newUser();
люьая функция вызваная через new называется функция конструктор

если вызывать функцию через new
1 создается пустой обьект
2 this устонавливается на текущий обьект
3 формируются свойства
4 возвращается обьект

fn User(props){
for (let key in props) {
  this[key] = props[key];
}
}
User.prototype.show=fn(){
это хранилище всех методов для класса User}
}


классы !!
чтобы создать класс надо
class User{
    constructor(name,age,zp){
    \\используется для создания свойств обьекта (передоваемые значи и знач по умолчанию)
    \\ конструктор вызывается автоматически
    this.name=name;
    this.age=age;
    this.zp=zp;
    }
    getZp(){
     return `${this.name}-${this.zp}`
    }

}

статические методы Date.now();
те что мы вызывали не создовая обьект

class User{
static date(){
let x =new Date();
return x.toLocaleString();
}
}

сеттеры и геттреы в классах
class User{
set info(x){
this.name=x}
}
get info(){
return this.name}
}
}

наследование
class Dom{
    constructor(app){

    }
 class User extends Dom{
       constructor(name,age,zp,app){
       super(app)
       }
     }

     super это линк на род класс
     let x =super.ce(elem,text)
     return x;



     асинхронные запросы !!
     ajax
     let xhr=new XMLHttpRequest();
     xhr.open(method,url,async);
              "GET" action  boolean
               str  str        eсли true то асинхрронный
                    or
                    http://
                    https://
     xhr.send(body);
              object to string "{age:22, city:awe}" только при post put
     body не нужен если работаем на получение инфы

     событие кот возникает если запрос наш прошел
        xhr.onload=fn

        onerror=fn если ошибка

        onabort=fn если отменен

        onprogress= возникает приполучении пакета

        onloadend когда загрузка завершина не завис от резтов


        xhr.onload=function(){xhr.statusCode}это ответы http
                                xhr.statusText расширенная инфа
        xhr.responce оответ кот получаем от нашего запроса
        xhr.responcType="x"
                           json
                           text
                           blob
                           document
        xhr.timeout = 3000000 времяотклика
        JSON.parce(xhr.responce) преобразование в обьект
        сирилизация преобразование обьекта к строке JSON.stringify({age:10})
        json это обьект




        обещания --- promise
        делает код ДЖС асинхронным
        любое промис имеет состояния resolve или reject (проще говоря true or false)
        let x =new Promose(callback);

        let x = (n) =>new Promise((res,rej)=>{
        if (x>=10) res(true)
        rej("error")
        });

        положительный рез-т хранится в x(10).then(callback);
        отрицательный x(0).catch(callback);

        fetch("url").then().catch()
home Wk
async function
generetor
iterator



fetch js глянуть
jq easing plugin
animate css
page2page
https://www.bestjquery.com/
галерея изображений fencybox 3
flexSlider 2
jquery mask plugin !!!
jqueryUI.com
bxSlider
datatables.net
fotorama
highlight jquery
jQ

jquery.com

$(selector).method();

hhh
https://webpack.js.org/https://webpack.js.org/
pug для формирования html
для работы вебпака нужен нодДЖС и НПМ

глянуть полифилд

перебирающие методы массива map filter forEACH и тд



react !!!
надо вебкап
нужно установить react-preset
                 react
                 react-dom
                 reactjs.org

в реакте надо писать не класс а класснайм и содержимое содержится в фигурынх скобках

props данные кот передаются от одного компонента к другому от родителея к дочке
ru.reactjs.org

жизненный цикл
1 Constructor {для создания внутр полей , пропсов , и тп}
static getDirevedStateFromProps(){}
2 render ()
3 ComponentDidMount (){вызывается один раз}
this.state хранилищи
this.state={
items:null
}

для изменения state используют this.setState()

1 state меняется только через вызов this.setState() передается обьект
2 при изменении состояния всегда происходти рендер


react-router
websocket
Ref
axios


redux это просто плагин кот можно пикрутить ко всему
это мелкое хранилище
оно условно глобально на весь проект

reducer это функция
которая может общатся со state


react portal рендерит содержимое вне дерева реакта

suspence




angular
дерективы
структурные
***
ngif
ngfor
ngswitch
ngswichcase
ngswichdefault


дерективы атрибуты
ngclass
ngstyle
ngshow
nghide


class.nameofclass="условие"
style.background="значение"

самописные дерективы



Observable
